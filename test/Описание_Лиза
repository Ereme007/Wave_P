На исходном сигнале, зная референтные разметки, выделить все qrs комплексы и "вырезеть" - 'занулить'
Полученный сигнал проанализировать между qrs комплексами:
    отметить на графике референтные значения (начало и конец P и конец T)
    наложить фильтр(ы)
    понять какой алгоритм необходимо сделать для нахождения P и T волны
    оценить погрешность с референтными значениями


Дополнения: P волна - "Определяем интервал поиска P-волны: половина Q-Q, но не дальше чем предыдущий Q + 150 мс, и не больше чем 1 секунда."


Задание от 12.05
- участок сигнала с зануленными QRS, отмеченными границами P-волны и участками поиска P-волны



Алгоритм выделения P-волны:
Состав:
На вход подается сигнал после НЧ-фильтра Баттерворта 2’ 20 Гц. (Фильтр Баттерворта - my_butter)
Отличается от Аналайзера тем, что:
    фильтр НЕ двунаправленный.
    граница Q может стоять в другом месте

Определяем интервал поиска P-волны: половина Q-Q, но не дальше чем предыдущий Q + 150 мс, и не больше чем 1 секунда.


Постановка задача: нахожденеи зубца P
Алгоритм: (на вход сигнал,  разметка начало и конца QRS)
    на сигнале "зануляем" QRS
    по формуле обпередяем область нахождения P
    выполняем my_butter() от 2 до 20
    выполняем Diff_Filt с расстоянием 20мск
    находим local_min и local_max на полученном сигнале в областях нахождения P
    определяем фронты [*]

    участок сигнала с зануленными QRS, отмеченными границами P-волны и участками поиска P-волны
- результат фильтрации, дифференциальный фильтр, который выделяет фронты P-волны
- результат детекции фронтов - метки всех фронтов подряд
- желательно, уже показать алгоритм первичной детекции P, который пробегает по всем фронтам и выбирает от 2 до 4 фронтов, лежащие в пределах ширины P-волны


[*] Алгоритм:
на участке области P рассматриваем все local_min и local_max, высчитываем амлитуду

pos[i] - это амплитуда на Diff_Filt 

Max_amp = 0
first_index = 0
last_index = 0

#Вылезет за край массива!
pos[] - локальные min и max в порядке по времени и в одной области
val[] == diff_sigmal[pos[]]
for (цикл от 1 области зубца P, который возможен в сигнале до последней области - OBL)
    
    for(int i = 1, i < колчиество точеек в одной области, i++)
    amp = 0
        
        for(k = i + 1, k < i + 4 && (k + 1) < length(колчиество точеек в одной области) && abs(pos[i] - pos[k]) < 80мск, k++) #тут вылезет!
                amp+ = abs(val[k-1] - val[k]) 
                f_index = i
                l_index = k
        end

        if (Max_amp < amp)
            Max_amp = amp
            first_index = i
            last_index = l_index
    end

    запоминаем, что на участке под номером OBL, амплитуду Max_amp, начало и конец first_index last_index
end

~заполняем массив 

return first_index, last_index, amp- тут наши фронты

Пояснения: 
Sign_Channel() - функция, записывающая в массив все отведения одного сигнала
All_Ref_QRS() - функция, которая считает в искусственном сигнале все точки начала и конца qrs (то есть из референтной размети вычисляется в каких точках дальше встречается qrs). Получается что на Нечётных индексах - это начало qrs, а на Чётных индексах массива - конец qrs
Zero_qrs() - зануление qrs (по половинке)
Simple_Zero_qes() - зануление по 'левому' краю для qrs
Segment_left_right_P() - определяет приблизительные участки qrs, в которых и будем искать фронты
All_points_with_channels_max_min() - функция определяющая по всем каналам на всех искомых цчастках для волны P max и min локальные значения
Massiv_Points_channel = Sort_points_with_channel() - сортируем точки по возрастанию на всех каналах по своим промежуткам (т.е.  Sort_points_with_channel[1] - означает для 1го канала рассматриваются все области поиска, на которых в порядке возрастания расставлены локальные точки)

#Пояснение многомерного массива "Massiv_Points_channel"
Massiv_Points_channel[channel] # на отведении channel столько отрезков (length)
Massiv_Points_channel[channel][2] #облать имеющий номер 2
Massiv_Points_channel[channel][2][1] #точка по X

amp_one_channel() #Нахождение амплитуды и границ по одному каналу (последняя цифра - номер канала)
Massiv_Amp_all_channels #Массив всех 12ти каналов по амплитуде и границам участков
