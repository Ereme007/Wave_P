На исходном сигнале, зная референтные разметки, выделить все qrs комплексы и "вырезеть" - 'занулить'
Полученный сигнал проанализировать между qrs комплексами:
    отметить на графике референтные значения (начало и конец P и конец T)
    наложить фильтр(ы)
    понять какой алгоритм необходимо сделать для нахождения P и T волны
    оценить погрешность с референтными значениями


Дополнения: P волна - "Определяем интервал поиска P-волны: половина Q-Q, но не дальше чем предыдущий Q + 150 мс, и не больше чем 1 секунда."


Задание от 12.05
- участок сигнала с зануленными QRS, отмеченными границами P-волны и участками поиска P-волны



Алгоритм выделения P-волны:
Состав:
На вход подается сигнал после НЧ-фильтра Баттерворта 2’ 20 Гц. (Фильтр Баттерворта - my_butter)
Отличается от Аналайзера тем, что:
    фильтр НЕ двунаправленный.
    граница Q может стоять в другом месте

Определяем интервал поиска P-волны: половина Q-Q, но не дальше чем предыдущий Q + 150 мс, и не больше чем 1 секунда.

Берем по всем каналам блоки получившейся длины перед точкой Q
Определяем максимальный размах на этом интервале по всем каналам.

Нормируем все каналы на максимальный размах, и умножаем на кол-во точек в интервале - видимо затем, чтобы сигнал был вписан в квадрат NxN, где N - количество точек на интервале (чтобы амплитуда была сопоставима с количеством точек).

Делим каждый канал на сегменты, макс. количество сегментов = 7.
Сегмент определяется рекурсивно: по двум крайним точкам, определяется (третья) средняя точка, которая соответствует максимальной площади треугольника, составленного из этих трех точек. Максимальная точка делит весь сегмент на два подсегмента, и процедура повторяется. Из двух сегментов выбирается сегмент с максимальной площадью треугольника, и делится еще на два сегмента - получается всего три сегмента. И так до тех пор, пока не появится 7 сегментов.

Записываем 7 точек разделения - в виде пар (позиция, амплитуда).

CountEssentials
По всем каналам:
//ищем существенные: длина выше порога и достаточно отклонен от горизонтали; 
//считаем количество каналов в которых точка лежит на существенном фронте

CalcSegmentInfo
Выбираем только те сегменты, для которых:
длина наклонной линии sqrt(dx*dx + dy*dy) больше отношения: количество сегментов, поделенное на удвоенное "целевое" количество сегментов (=5), и это бред, т.к. длина линии всегда больше единицы, а этот коэффициент всегда будет меньше единицы - всегда будет срабатывать
размах по (нормированной к точкам) амплитуде больше 0.75 * длина линии (отношение катета к гипотенузе = какой-то тангенс угла?)

Для всех выбранных сохраняем:
угол = размах / длина линии
длина линии
номер в исходном массиве сегментов

Если количество сегментов больше целевого (5), то: (!! пересортировки)
удаляем из выбранных половину от избыточного количества - с наиболее вертикальным наклоном
удаляем из выбранных половину от избыточного количества - с максимальной длиной

Для всех оставшихся сегментов:
сведение позиций сегментов по всем каналам: в один общий массив нулей прибавляем +1 на всем интервале сегмента (это самый сильный ход во всем этом алгоритме!)
при этом особая забота, чтобы в крайних точках были нули…

Выбираем те точки, на которые попало сегментов больше, чем 0.35 от количества каналов.

Объединяем эти точки в интервалы (участок между двумя такими точками, конец не включительно).

Объединяем недалеко стоящие интервалы (сразу нельзя было усреднить в окне?..).
До тех пор, пока начало следующих интервалов отстоит от начала первого менее чем на N.. (из-за такого условия скорее всего захватывает слишком раннюю точку...)

PQ не меньше 90 мс (сразу отсекаем всякие нарушения проводимости?)
Выбираем с конца такой интервал, начало которого больше 90 мс.


	










Постановка задача: нахожденеи зубца P
Алгоритм: (на вход сигнал,  разметка начало и конца QRS)
    на сигнале "зануляем" QRS
    по формуле обпередяем область нахождения P
    выполняем my_butter() от 2 до 20
    выполняем Diff_Filt с расстоянием 20мск
    находим local_min и local_max на полученном сигнале в областях нахождения P
    определяем фронты [*]

    участок сигнала с зануленными QRS, отмеченными границами P-волны и участками поиска P-волны
- результат фильтрации, дифференциальный фильтр, который выделяет фронты P-волны
- результат детекции фронтов - метки всех фронтов подряд
- желательно, уже показать алгоритм первичной детекции P, который пробегает по всем фронтам и выбирает от 2 до 4 фронтов, лежащие в пределах ширины P-волны




[*] Алгоритм:
на участке области P рассматриваем все local_min и local_max, высчитываем амлитуду

pos[i] - это амплитуда на Diff_Filt 

Max_amp = 0
first_index = 0
last_index = 0

#Вылезет за край массива!
pos[] - локальные min и max в порядке по времени и в одной области
val[] == diff_sigmal[pos[]]
for (цикл от 1 области зубца P, который возможен в сигнале до последней области - OBL)
    
    for(int i = 1, i < колчиество точеек в одной области, i++)
    amp = 0
        
        for(k = i + 1, k < i + 4 && (k + 1) < length(колчиество точеек в одной области) && abs(pos[i] - pos[k]) < 80мск, k++) #тут вылезет!
                amp+ = abs(val[k-1] - val[k]) 
                f_index = i
                l_index = k
        end

        if (Max_amp < amp)
            Max_amp = amp
            first_index = i
            last_index = l_index
    end

    запоминаем, что на участке под номером OBL, амплитуду Max_amp, начало и конец first_index last_index
end

~заполняем массив 

return first_index, last_index, amp- тут наши фронты

#468 строчка
Пояснения: 
Sign_Channel() - функция, записывающая в массив все отведения одного сигнала
All_Ref_QRS() - функция, которая считает в искусственном сигнале все точки начала и конца qrs (то есть из референтной размети вычисляется в каких точках дальше встречается qrs). Получается что на Нечётных индексах - это начало qrs, а на Чётных индексах массива - конец qrs
Zero_qrs() - зануление qrs (по половинке)
Simple_Zero_qes() - зануление по 'левому' краю для qrs
Segment_left_right_P() - определяет приблизительные участки qrs, в которых и будем искать фронты
All_points_with_channels_max_min() - функция определяющая по всем каналам на всех искомых цчастках для волны P max и min локальные значения
Massiv_Points_channel = Sort_points_with_channel() - сортируем точки по возрастанию на всех каналах по своим промежуткам (т.е.  Sort_points_with_channel[1] - означает для 1го канала рассматриваются все области поиска, на которых в порядке возрастания расставлены локальные точки)

#Пояснение многомерного массива "Massiv_Points_channel"
Massiv_Points_channel[channel] # на отведении channel столько отрезков (length)
Massiv_Points_channel[channel][2] #облать имеющий номер 2
Massiv_Points_channel[channel][2][1] #точка по X

amp_one_channel() #Нахождение амплитуды и границ по одному каналу (последняя цифра - номер канала)
Massiv_Amp_all_channels #Массив всех 12ти каналов по амплитуде и границам участков



Выяснить:
(1) !! как считывать не массивом одного сигнала по 12 каналов, а сразу по I II III и тд (пока что реализован массив, где 1 - I, 2 - II, 3 - III, 4 - aVR и тд)
signals_channel = Sign_Channel(signals) #12 каналов (реализация в Function_P.jl)


